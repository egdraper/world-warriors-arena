import { Component, HostListener, OnInit } from '@angular/core';
import { GSM } from '../../app.service.manager';
import { DefaultMapSettings, GridMapCell, GRID_CELL_MULTIPLIER } from '../../models/cell.model';
import { GridMapGenerator } from '../../utils/grid-map-generator';

@Component({
  selector: 'world-warriors-arena-global-map',
  templateUrl: './global-map.component.html',
  styleUrls: ['./global-map.component.scss']
})
export class GlobalMapComponent implements OnInit {
  public gridOfGrids: GridMapCell[][] = []

  public gridCanvasContext: CanvasRenderingContext2D;
  public maxHeight = 5
  public maxWidth = 5

  private controlPressed = false
  private mouseIsDown = false

  public ngOnInit(): void {
    for (let i = 0; i < this.maxHeight; i++) {
      this.gridOfGrids[i] = [];

      for (let l = 0; l < this.maxWidth; l++) {
        this.gridOfGrids[i][l] = { x: l, y: i }
      }
    }

  }

  @HostListener("document:keydown", ["$event"])
  public onKeyDown(event: KeyboardEvent): void {
    if (event.key === "Control") {
      this.controlPressed = true
    }
  }

  @HostListener("document:keyup", ["$event"])
  public onKeyUp(event: KeyboardEvent): void {
    if (event.key === "Control") {
      this.controlPressed = false
    }
  }

  public onGridCellClick(gridCell: GridMapCell, mouseEvent: MouseEvent, gridCanvas: HTMLCanvasElement): void {
    gridCell.context = gridCanvas.getContext('2d');
    gridCell.gridCanvas = gridCanvas
    gridCell.relationX = (GSM.Map.activeMap.width * GRID_CELL_MULTIPLIER) / 200
    gridCell.relationY = (GSM.Map.activeMap.height * GRID_CELL_MULTIPLIER) / 200

    gridCanvas.height = 200
    gridCanvas.width = 200

    gridCell.context.imageSmoothingEnabled = false

    gridCell.context.fillStyle = 'yellow'
    gridCell.context.fillRect(
      0,
      0,
      200,
      200
    )

  }

  public onMouseDown(gridCell: GridMapCell, mouseEvent: MouseEvent): void {
    this.mouseIsDown = true
  }

  public onMouseUp(gridCell: GridMapCell, mouseEvent: MouseEvent): void {
    this.mouseIsDown = false
  }

  public onMouseMove(gridCell: GridMapCell, mouseEvent: MouseEvent): void {
    if (gridCell.gridCanvas && this.controlPressed && this.mouseIsDown) {
      if (!gridCell.markers) { gridCell.markers = [] }
      gridCell.markers.push({ x: mouseEvent.offsetX, y: mouseEvent.offsetY })
      gridCell.context.beginPath();
      gridCell.context.moveTo(mouseEvent.offsetX, mouseEvent.offsetY);
      gridCell.context.strokeStyle = "red";
      gridCell.context.lineWidth = Math.round(200 / gridCell.relationX);
      gridCell.context.lineCap = "round";
      gridCell.context.lineJoin = "round";
      gridCell.context.lineTo(mouseEvent.offsetX, mouseEvent.offsetY);
      gridCell.context.stroke();
    }
  }

  public generateMaps(): void {

    const mapDetails: DefaultMapSettings = {
      autoGeneratedMap: true,
      backgroundTypeId: "greenGrass",
      terrainTypeId: "DrawableTrees",
      inverted: false,
      pathTypeId: "DrawableDirtRoad",
    }
    const map = GSM.Map.createNewGrid(60, 60, mapDetails)
    GSM.Canvas.setupCanvases()

   
    GridMapGenerator.autoFillBackgroundTerrain(map ,"caveDirt")
    GridMapGenerator.generateMap(map, this.gridOfGrids[0][0], mapDetails)
  }
}
