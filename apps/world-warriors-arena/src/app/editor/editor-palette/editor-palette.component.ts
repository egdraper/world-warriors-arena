import { Component, OnInit } from '@angular/core';
import { CanvasService } from '../../canvas/canvas.service';
import { AssetsService } from '../../game-assets/assets.service';
import { GameMarkersService } from '../../game-assets/game-markers';
import { growableItems } from '../../game-assets/tiles.db.ts/tile-assets.db';
import { DrawService } from '../../game-engine/draw-tools/draw.service';
import { GridService } from '../../game-engine/grid.service';
import { NewFogOfWarService } from '../../game-engine/new-visibility.service';
import { ShortestPath } from '../../game-engine/shortest-path';
import { DefaultMapSettings, MarkerIconType, SpriteTile } from '../../models/cell.model';
import { GameSettings } from '../../models/game-settings';
import { MarkerIcon, PageTransitionMarker } from '../../models/markers-icons';
import { RandomMapGenerator } from '../map-generator/random-map-generator';
import { EditorService } from './editor.service';

@Component({
  selector: 'world-warriors-arena-editor-palette',
  templateUrl: './editor-palette.component.html',
  styleUrls: ['./editor-palette.component.scss']
})
export class EditorPaletteComponent implements OnInit {
  public images: any[] = []
  public imageArray: any[] = []
  public currentImageSrc: string = ""
  public lockState = "Locked"

  constructor(
    public assetService: AssetsService,
    public canvasService: CanvasService,
    private editorService: EditorService,
    private shortestPath: ShortestPath,
    public grid: GridService,
    private drawService: DrawService,
    private visibilityService: NewFogOfWarService,
    private gameMarkerService: GameMarkersService
  ) {
    this.gameMarkerService.iconClick.subscribe(this.onGameMarkerClicked.bind(this))

  }

  ngOnInit(): void {
    this.imageArray = this.editorService.findObjectCollection("trees")
  }

  public onSelectionChange(change: any): void {
    this.editorService.selectedGrowableAsset = growableItems.find(item => item.name === change.value).id
  }

  public onTilesChange(change: any): void {
    this.imageArray = this.editorService.findObjectCollection(change.value)
  }

  public tileClick(tile: SpriteTile): void {
    this.editorService.selectedAsset = tile
  }

  public switchGrid(gridId: string): void {
    this.grid.switchGrid(gridId)
  }

  public changeLockState(): void {
    this.lockState = this.lockState === "Locked" ? "UnLocked" : "Locked"

    if (this.lockState === "Locked") {
      if (this.assetService.selectedGameComponent) {
        this.canvasService.centerOverAsset(this.assetService.selectedGameComponent, this.grid.activeGrid)
      }
      GameSettings.gm = false
    } else {
      GameSettings.gm = true
    }

  }

  public baseClicked(): void {
    this.editorService.layerID++
    // this.editorService.baseOnly = true
  }

  public changeScale(scale: any): void {
    const tempViewPortX = this.canvasService.canvasViewPortOffsetX
    const tempViewPortY = this.canvasService.canvasViewPortOffsetY

    this.canvasService.resetViewport()
    GameSettings.scale = Number(scale.value)

    this.canvasService.setupCanvases()
    this.editorService.backgroundDirty = true
    this.assetService.obstaclesDirty = true

    let perfectHeight = window.innerHeight

    while (perfectHeight % (GameSettings.scale * 32) !== 0) {
      perfectHeight--
    }

    this.canvasService.maxCellCountX = perfectHeight / (32 * GameSettings.scale)
    // this.canvasService.adustViewPort(tempViewPortX, tempViewPortY)


  }

  public invertedClicked(): void {
    this.grid.activeGrid.defaultSettings.inverted = !this.grid.activeGrid.defaultSettings.inverted
  }

  public onGameMarkerClicked(markerIcon: MarkerIcon): void {
    if (markerIcon.type === MarkerIconType.mapTransition) {
      this.generateRandomAttachmentMap(markerIcon as PageTransitionMarker)
    }
  }

  public generateRandomAttachmentMap(markerIcon: PageTransitionMarker): void {
    const mapGenerator = new RandomMapGenerator(this.editorService, this.shortestPath, this.grid, this.gameMarkerService)
   
    // allow for override
    const mapDetails: DefaultMapSettings = {
      autoGeneratedMap: true,
      backgroundTypeId: "greenGrass",
      terrainTypeId: "DrawableTrees",
      inverted: false,
      pathTypeId: "DrawableDirtRoad"
    }
   
    mapGenerator.generateAttachmentMap(this.grid.activeGrid, mapDetails, markerIcon)
    this.canvasService.setupCanvases()

    // CLEANUP - Rethink the "Dirty" locations, if they should be in drawing service or where they are
    this.assetService.obstaclesDirty = true
    this.editorService.backgroundDirty = true

    // CLEANUP - Needs to be moved into somewhere that re-draws
    const centerCell = this.grid.activeGrid.getGridCellByCoordinate(Math.floor(this.canvasService.canvasSizeX / 2), Math.floor(this.canvasService.canvasSizeY / 2))
    this.canvasService.centerPointX = centerCell.posX * GameSettings.scale
    this.canvasService.centerPointY = centerCell.posY * GameSettings.scale

    this.drawService.blackOutFogPainter.paint()
    this.visibilityService.createCellLines()
  }

  public generateRandomCoreMap(): void {
    const mapGenerator = new RandomMapGenerator(this.editorService, this.shortestPath, this.grid, this.gameMarkerService)

    const mapDetails: DefaultMapSettings = {
      autoGeneratedMap: true,
      backgroundTypeId: "greenGrass",
      terrainTypeId: "DrawableTrees",
      inverted: false,
      pathTypeId: "DrawableDirtRoad",
    }

    mapGenerator.generateMap(45, 45, mapDetails)
    this.canvasService.setupCanvases()

    // CLEANUP - Rethink the "Dirty" locations, if they should be in drawing service or where they are
    this.assetService.obstaclesDirty = true
    this.editorService.backgroundDirty = true

    // CLEANUP - Needs to be moved into somewhere that re-draws
    const centerCell = this.grid.activeGrid.getGridCellByCoordinate(Math.floor(this.canvasService.canvasSizeX / 2), Math.floor(this.canvasService.canvasSizeY / 2))
    this.canvasService.centerPointX = centerCell.posX * GameSettings.scale
    this.canvasService.centerPointY = centerCell.posY * GameSettings.scale

    this.drawService.blackOutFogPainter.paint()
    this.visibilityService.createCellLines()
  }
}
